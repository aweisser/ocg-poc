// Code generated by goagen v1.3.0, DO NOT EDIT.
//
// API "ocg": Application User Types
//
// Command:
// $ goagen
// --design=github.com/aweisser/ocg-poc/cmd/ocg-rest-server/design
// --out=$(GOPATH)\src\github.com\aweisser\ocg-poc\cmd\ocg-rest-server\
// --version=v1.1.0-dirty

package app

import (
	"github.com/goadesign/goa"
	uuid "github.com/satori/go.uuid"
	"unicode/utf8"
)

// dataKindUUID user type.
type dataKindUUID struct {
	// UUID of the object
	ID   *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the dataKindUUID type instance.
func (ut *dataKindUUID) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	return
}

// Publicize creates DataKindUUID from dataKindUUID
func (ut *dataKindUUID) Publicize() *DataKindUUID {
	var pub DataKindUUID
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// DataKindUUID user type.
type DataKindUUID struct {
	// UUID of the object
	ID   uuid.UUID `form:"id" json:"id" xml:"id"`
	Type string    `form:"type" json:"type" xml:"type"`
}

// Validate validates the DataKindUUID type instance.
func (ut *DataKindUUID) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	return
}

// genericData user type.
type genericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates GenericData from genericData
func (ut *genericData) Publicize() *GenericData {
	var pub GenericData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// GenericData user type.
type GenericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// genericLinks user type.
type genericLinks struct {
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinks from genericLinks
func (ut *genericLinks) Publicize() *GenericLinks {
	var pub GenericLinks
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinks user type.
type GenericLinks struct {
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// genericLinksForMember user type.
type genericLinksForMember struct {
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinksForMember from genericLinksForMember
func (ut *genericLinksForMember) Publicize() *GenericLinksForMember {
	var pub GenericLinksForMember
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinksForMember user type.
type GenericLinksForMember struct {
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type jSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail *string `form:"detail,omitempty" json:"detail,omitempty" xml:"detail,omitempty"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*jSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the jSONAPIError type instance.
func (ut *jSONAPIError) Validate() (err error) {
	if ut.Detail == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "detail"))
	}
	return
}

// Publicize creates JSONAPIError from jSONAPIError
func (ut *jSONAPIError) Publicize() *JSONAPIError {
	var pub JSONAPIError
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.Detail != nil {
		pub.Detail = *ut.Detail
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = make(map[string]*JSONAPILink, len(ut.Links))
		for k2, v2 := range ut.Links {
			pubk2 := k2
			var pubv2 *JSONAPILink
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Links[pubk2] = pubv2
		}
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Source != nil {
		pub.Source = ut.Source
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	if ut.Title != nil {
		pub.Title = ut.Title
	}
	return &pub
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type JSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail string `form:"detail" json:"detail" xml:"detail"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*JSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the JSONAPIError type instance.
func (ut *JSONAPIError) Validate() (err error) {
	if ut.Detail == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "detail"))
	}
	return
}

// See also http://jsonapi.org/format/#document-links.
type jSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates JSONAPILink from jSONAPILink
func (ut *jSONAPILink) Publicize() *JSONAPILink {
	var pub JSONAPILink
	if ut.Href != nil {
		pub.Href = ut.Href
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// See also http://jsonapi.org/format/#document-links.
type JSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// member user type.
type member struct {
	Attributes *memberAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The unique ID of the member
	ID            *string                `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinksForMember `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *memberRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the member type instance.
func (ut *member) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "members") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"members"}))
		}
	}
	return
}

// Publicize creates Member from member
func (ut *member) Publicize() *Member {
	var pub Member
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// Member user type.
type Member struct {
	Attributes *MemberAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// The unique ID of the member
	ID            *string                `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinksForMember `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *MemberRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Member type instance.
func (ut *Member) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "members") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"members"}))
	}
	return
}

// memberRelationships user type.
type memberRelationships struct {
	// A Member can link external accounts like github or stackoverflow.
	Accounts *relationGeneric `form:"accounts,omitempty" json:"accounts,omitempty" xml:"accounts,omitempty"`
}

// Publicize creates MemberRelationships from memberRelationships
func (ut *memberRelationships) Publicize() *MemberRelationships {
	var pub MemberRelationships
	if ut.Accounts != nil {
		pub.Accounts = ut.Accounts.Publicize()
	}
	return &pub
}

// MemberRelationships user type.
type MemberRelationships struct {
	// A Member can link external accounts like github or stackoverflow.
	Accounts *RelationGeneric `form:"accounts,omitempty" json:"accounts,omitempty" xml:"accounts,omitempty"`
}

// relationGeneric user type.
type relationGeneric struct {
	Data  *genericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGeneric from relationGeneric
func (ut *relationGeneric) Publicize() *RelationGeneric {
	var pub RelationGeneric
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGeneric user type.
type RelationGeneric struct {
	Data  *GenericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGenericList user type.
type relationGenericList struct {
	Data  []*genericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGenericList from relationGenericList
func (ut *relationGenericList) Publicize() *RelationGenericList {
	var pub RelationGenericList
	if ut.Data != nil {
		pub.Data = make([]*GenericData, len(ut.Data))
		for i2, elem2 := range ut.Data {
			pub.Data[i2] = elem2.Publicize()
		}
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGenericList user type.
type RelationGenericList struct {
	Data  []*GenericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationKindUUID user type.
type relationKindUUID struct {
	Data  *dataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the relationKindUUID type instance.
func (ut *relationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationKindUUID from relationKindUUID
func (ut *relationKindUUID) Publicize() *RelationKindUUID {
	var pub RelationKindUUID
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationKindUUID user type.
type RelationKindUUID struct {
	Data  *DataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the RelationKindUUID type instance.
func (ut *RelationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// memberAttributes user type.
type memberAttributes struct {
	// Name of the member
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// Validate validates the memberAttributes type instance.
func (ut *memberAttributes) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// Publicize creates MemberAttributes from memberAttributes
func (ut *memberAttributes) Publicize() *MemberAttributes {
	var pub MemberAttributes
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	return &pub
}

// MemberAttributes user type.
type MemberAttributes struct {
	// Name of the member
	Name string `form:"name" json:"name" xml:"name"`
}

// Validate validates the MemberAttributes type instance.
func (ut *MemberAttributes) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ok := goa.ValidatePattern(`^[^_|-].*`, ut.Name); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, ut.Name, `^[^_|-].*`))
	}
	if utf8.RuneCountInString(ut.Name) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 1, true))
	}
	if utf8.RuneCountInString(ut.Name) > 62 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 62, false))
	}
	return
}
